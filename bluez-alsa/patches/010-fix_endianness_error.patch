diff --git a/src/a2dp-sbc.c b/src/a2dp-sbc.c
index 1580db5..157c38a 100644
--- a/src/a2dp-sbc.c
+++ b/src/a2dp-sbc.c
@@ -181,6 +181,8 @@ void *a2dp_sbc_enc_thread(struct ba_transport_thread *th) {
 
 	/* initialize SBC encoder bit-pool */
 	sbc.bitpool = sbc_a2dp_get_bitpool(configuration, config.sbc_quality);
+	/* ensure libsbc uses little-endian PCM on all architectures */
+	sbc.endian = SBC_LE;
 
 #if DEBUG
 	sbc_print_internals(&sbc);
@@ -228,6 +230,7 @@ void *a2dp_sbc_enc_thread(struct ba_transport_thread *th) {
 			if (errno == ESTALE) {
 				sbc_reinit_a2dp(&sbc, 0, configuration, sizeof(*configuration));
 				sbc.bitpool = sbc_a2dp_get_bitpool(configuration, config.sbc_quality);
+				sbc.endian = SBC_LE;
 				ffb_rewind(&pcm);
 				continue;
 			}
@@ -336,6 +339,8 @@ void *a2dp_sbc_dec_thread(struct ba_transport_thread *th) {
 		error("Couldn't initialize SBC codec: %s", strerror(errno));
 		goto fail_init;
 	}
+	/* ensure libsbc uses little-endian PCM on all architectures */
+	sbc.endian = SBC_LE;
 
 	ffb_t bt = { 0 };
 	ffb_t pcm = { 0 };
diff --git a/src/audio.c b/src/audio.c
index c384029..946acf1 100644
--- a/src/audio.c
+++ b/src/audio.c
@@ -102,13 +102,15 @@ void audio_scale_s16_2le(int16_t *buffer, size_t frames,
 	case 1:
 		if (ch1 != 0 && ch1 != 1)
 			while (frames--)
-				buffer[frames] *= ch1;
+				buffer[frames] = (int16_t)htole16((int16_t)le16toh(buffer[frames]) * ch1);
 		break;
 	case 2:
 		if ((ch1 != 0 && ch1 != 1) || (ch2 != 0 && ch2 != 1))
 			while (frames--) {
-				buffer[2 * frames] *= ch1;
-				buffer[2 * frames + 1] *= ch2;
+				int16_t *ptr = &buffer[2 * frames];
+				*ptr = (int16_t)htole16((int16_t)le16toh(*ptr) * ch1);
+				++ptr;
+				*ptr = (int16_t)htole16((int16_t)le16toh(*ptr) * ch2);
 			}
 		break;
 	default:
@@ -125,13 +127,15 @@ void audio_scale_s32_4le(int32_t *buffer, size_t frames,
 	case 1:
 		if (ch1 != 0 && ch1 != 1)
 			while (frames--)
-				buffer[frames] *= ch1;
+				buffer[frames] = (int32_t)htole32((int32_t)le32toh(buffer[frames]) * ch1);
 		break;
 	case 2:
 		if ((ch1 != 0 && ch1 != 1) || (ch2 != 0 && ch2 != 1))
 			while (frames--) {
-				buffer[2 * frames] *= ch1;
-				buffer[2 * frames + 1] *= ch2;
+				int32_t *ptr = &buffer[2 * frames];
+				*ptr = (int32_t)htole32((int32_t)le32toh(*ptr) * ch1);
+				++ptr;
+				*ptr = (int32_t)htole32((int32_t)le32toh(*ptr) * ch2);
 			}
 		break;
 	default:
diff --git a/src/shared/dbus-client.h b/src/shared/dbus-client.h
index 6d2dd49..dbe4531 100644
--- a/src/shared/dbus-client.h
+++ b/src/shared/dbus-client.h
@@ -12,6 +12,7 @@
 #ifndef BLUEALSA_SHARED_DBUSCLIENT_H_
 #define BLUEALSA_SHARED_DBUSCLIENT_H_
 
+#include <endian.h>
 #include <poll.h>
 #include <stddef.h>
 #include <stdint.h>
@@ -170,12 +171,23 @@ struct ba_pcm {
 
 	/* 16-bit packed PCM volume */
 	union {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
 		struct {
 			dbus_uint16_t ch2_volume:7;
 			dbus_uint16_t ch2_muted:1;
 			dbus_uint16_t ch1_volume:7;
 			dbus_uint16_t ch1_muted:1;
 		};
+#elif __BYTE_ORDER == __BIG_ENDIAN
+		struct {
+			dbus_uint16_t ch1_muted:1;
+			dbus_uint16_t ch1_volume:7;
+			dbus_uint16_t ch2_muted:1;
+			dbus_uint16_t ch2_volume:7;
+		};
+#else
+#error "Unknown byte order"
+#endif
 		dbus_uint16_t raw;
 	} volume;
 
